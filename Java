1. Why String is an immutable class
2. What is immutable class, how to create custom immutable class
3. What will happen if we clone immutable class
4. Talk about memory allocation for different wrapper classes
5. Abstraction,  encapsulation and its significance with real time examples
6. Class loaders in java
7. SOLID principles
8. What is generics
9. Generics
10. When u hv hashtable why u need to go to synchronized hashmap
11. Java 8 features
12. What is lambda expression
13. How do u create custom function interface
14. One problem from stream api
15. What is the function interface used in filter and map
16. Predicate,  supplier  , consumer and function
17. What is flat map
---------
serialisation in java
serialization -
Classes that are eligible for serialization need to implement a special marker interface Serializable.

The most important method in ObjectOutputStream is:
public final void writeObject(Object o) throws IOException;
Which takes a serializable object and converts it into a sequence (stream) of bytes. 

Similarly, the most important method in ObjectInputStream is:
public final Object readObject() 
  throws IOException, ClassNotFoundException;
Which can read a stream of bytes and convert it back into a Java object. This can then be cast back to the original object.

static fields belong to a class, and are not serialized
we can use the keyword transient to ignore class fields during serialization

NotSerializableException

InvalidClassException

Ref: 
https://www.baeldung.com/java-serialization
https://www.geeksforgeeks.org/serialization-in-java/


what are marker interfaces in java and what marker interface mean?
a marker interface has no data member and method
It is used to “mark” java classes so that objects of these classes may get certain capability. 
Other examples of marker interfaces are:- Cloneable and Remote.

transient keyword?
https://www.geeksforgeeks.org/transient-keyword-java/
-----------
HashMap vs SynchronizedMap vs HashTable vs ConcurrentHashMap

HashMap
Not thread-safe
Can have one null key and multiple null values

SynchronizedMap
thread-safe
Slow performance
null key and multiple null values are allowed

HashTable
thread-safe
Slow performance
null key-and-values are not allowed

ConcurrentHashMap
thread-safe
fast performance
null key-and-values are not allowed
Map is divieded into 16 segments
when we are doing write operation, only that particular thread is locked
so we can write to another segement, which results in faster response bcz of less waiting time.
incase of read, no lock. any number of threads can read.

Ref:
https://youtu.be/UwurUtvil7w
-----------
Arrays.asList()
List.of()

distinct ()

collect(Collecters.toList())

For custom classes, implement equals method for the variable which we want distinct.

Collections.singletonList()


----
Why String is immutable?
-------
interface vs abstract class
interface A {

}



abstract class A {

}

all interface methods are by default -  public abstract
abstract methods doesn't have a body

abstract class contains abstract, concrete methods

multiple inheritance can be achieved by Inheritance
same can't be achieved by abstract class

variables -
interface : by default, public static final  and intialisation of variables is mandatory.
abstract class: no restrictions on variables and on intialisation of variables

constructor -
interface - can't have a constructor
abstract class - can have a constructor
can't create an object for both interface and abstract as methods are not defined 

Ref:
https://www.youtube.com/watch?v=Ud0zfImgbYw
-------
How hashmap works?
hashcode collision

Map Interface
HashMap class

Array of buckets,
each bucket is a node/linkedlist
16 default bucket size

hashMap.put(key,value)
hashCode of key is calcualted
hashCode helps to find index/bucket

if hashCode is bigger number then lot of space goes array allocation
instead of that we do modular operation on hashCode

after index is calculated it's stored in that index related node/bucket
each node is a linkedlist
each node stores the following values
key, value, hashCode, next

node = hashCode | key | value | null

hashMap.put(key2,value2)
calculated hashCode of key2
using hashCode, index is calculated

if two keys return same hashCode, then it's hashCollision
then another node is created in the linkedlist where already one node is present


hashCode | key | value | points to next node -->  hashCode | key2 | value2 | null

in map, we can enter null as key.
when ever key is null, it goes to 0 index


Map<String,Integer> map = new HashMap<>();
map.put("aaa",1);

map has size, table
default size - 16
table has array of buckets
table = HashMap$Node<K,V>
$ signifies Node is innerClass of HashMap

String str1 = "FB";
String str2 = "Ea";
str1, str2 return same hashCode

if two keys return same hashCode, then it's hashCollision
str1 is stored in first node, str2 in second node of same linkedlist


#During duplicate key
latest value gets updated

#During null key
when ever key is null, it goes to 0 index

loadFactor, threshold 
default loadFactor=0.75
when map is 75% full, table size will be doubled

how do we know map is 75% full, we come to know by threshold
threshold = loadFactor * size
default threshold = 0.75 * 16 = 12

when map crosses threshold, table size will be doubled


# get operation
hashCode of key is compared
then equals() method to compare key
if key doesn't match goes to next node of the linkedList and does same
once key is matched, we will get the value of the key  

Ref:
https://www.youtube.com/watch?v=CojCE-ojdGY
https://www.youtube.com/watch?v=fSjxhOYPBRI
https://www.youtube.com/watch?v=AVSGJHrrLpE
----------

equals and hashcode

List vs Set

ArrayList Internals

Failfast vs Failsafe collections
failsafe consumes more memory as it creates a copy

ArrayList<String> namesList = new ArrayList<>();
List<String> listofNames = Arrays.asList("pavan","bhavani","kumar","kari");
namesList.addAll(listofNames);
for(String name : namesList ){
System.out.println(name);
namesList.remove(2); // throws java.util.ConcurrentModificationException
}

Iterator<String> nameIterator = namesList.iterator();
while(nameIterator.hasNext()){
	String currName = nameIterator.next();
	if(currName.equals("pavan")){
		nameIterator.remove();
		System.out.println();
	}
}



The asList() method of java.util.Arrays class is used to return a fixed-size list backed by the specified array. 
public static List asList(T... a)


new CopyOnWriteArrayList<>();
then we can add to the list without java.util.ConcurrentModificationException

Singleton design pattern
GOF Singleton vs Spring Singleton

How implement singleton design pattern in java


Factory Design Pattern
------
stream api, complex methods like grouping by
immutable class
hashmap customer key object
