1. diff b.w controller and rest controller 
@RestController = @Controller + @ResponseBody

@RequestMapping(value="/<uri>", method=RequestMethod.POST, produces="application/json")
produces="application/json" or "application/xml" - method produces output in that format
@RequestBody
---------
2. diff b.w spring and spring boot
spring - 
provides multiple modules like (spring core, spring aop, spring jdbc)

Dependency Injection using @Component, @Autowired
@Component - we tell Spring framework, this is a bean that you need to manage
@Autowired - find correct match for this specific type and autowire it in.

Spring solved the following problems
1. Duplication/Plumbing Code -
Spring JDBC, Spring MVC, Spring AOP, Spring ORM, Spring JMS, Spring Test

2. Good Integration with Other frameworks
Hibernate for ORM
iBatis for Object Mapping
JUnit & Mockito for Unit Testing

Why we need Spring Boot -
Spring based applications have a lot of configuration

Autoconfiguration
Starter projects

spring boot -
helps to create standalone application
less or almost zero configuration
Autoconfiguration is a special feature in spring boot

Benefits of Spring Boot over Spring -
Dependency resolution
Min configuration
Embedded server for testing
Bean auto scan
Health metrics

Bean auto scan
spring - 
<context:component-scan base-package="com.*"></context:component-scan>

spring-boot -
@SpringBootApplication
@ComponentScan(base-package="")
or
if don't want to use the ComponentScan follow package structure
basepackage is where main method present
for remaining follow basepackage.controller/service like that so no need to mention ComponentScan
---------------------
3. diff b.w component and service annotation

@Component  - marks java class as bean
@Service -  service layer classes for intent - service layer
@Repository -  for DAO layer  
@Controller  - Presentation layer
@Configuration - a class contains one more beans defined inside class

@Bean - to declare a single bean explicitly 
------------
4. profiles in spring

No active profile set, falling back to default properties: default
application.yml
spring.profiles.active: test -- then test profile is used
application-<profileName>.<extn> -- application-test.yml
or
java -jar spring-boot-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=test

selecting beans by profile -
@Profile("<env>") on top of bean
-------
Spring Boot:
How do handle security in Spring boot application
How do u run Springboot in other port
How do u run SB applications in another server by removing tomcat
Annotations specifically used in Springboot
What is the significance of @componentscan @configuration
What @enableautoconfiguration does
Example of stater packages
How do u connect to backend
-------
ConfigurableApplicationContext context = SpringApplication.run(class, args); 
This is initialisation of spring container

When we annotate a class with @Component, a bean/object of that class created.
context.getBean(ClassName) - here we are getting object of ClassName from the container.

By default, spring follows singleton design pattern i.e creates an singleton object/bean for all @Component and similar annotated classes.

If we want to create multiple references/objects/beans of a class then we need to use the following annonation
@Scope(value="prototype")
But now spring doesn't create any instance of the class unless we call getBean().

When a classA is dependent on  classB,
Then we need to annotate classB with @Component, so bean is created for classB.
Now we need to inject/use classB bean/object in classA,
So by adding @Autowired classB instaceName in classA, we can use classB in classA.

By default, spring creates bean based on ClassName, if we want to create a bean using any specific name then we need to mention like below.
@Component("withwhatNameBeanNeedtobeCreated)

@Autowired -- searchs by type i.e ClassName
@Qualifier("nameOfthebeanwewantToSearch)
We need to add @Qualifier along with @Autowired if we want to search by name we given to bean.

Ref : https://youtu.be/K43qyHJXmWI
------
ApplicationContext context = new AnnonationConfigApplicationContext(AppConfig.class); 
This is spring container

ClassA classA = context.getBean(ClassA.class);

@Configuration
Class annotated with @Configuration i.e AppConfig is responsible for bean creation.

@Configuration
public class AppConfig {

@Bean
public ClassA getInstance(){
return new ClassA();
}

}

Ref: https://youtu.be/5zUTc-kge8I
-------
What're diff contexts available in spring and when to  use them?
ApplicationContext context = new AnnonationConfigApplicationContext(AppConfig.class);

ConfigurableApplicationContext context = SpringApplication.run(class, args); 
This is initialisation of spring container

What are diff ways of getting a bean from container other than context.getBean()

How to inject a bean by not using @Autowired?
What're diff ways to inject a bean by not using @Autowired?

What're uses of @Qualifer?

------







How does basic authentication works in REST API?
session based
JWT based

session based or JWT based , JWT based is prefered
as we may have multiple servers and session is specific to a server

we wll get JWT token once authentication done
so JWT is for authorisation

what is content negotiation?
consumes={MediaType.APPLICATION_XML_VALUE,MediaType.APPLICATION_JSON_VALUE},
produces={MediaType.APPLICATION_JSON_VALUE}

What are cross cutting concerns?
For all cross cutting concerns Spring AOP is solution

How do we implement cross cutting concerns in microservices architecture?
GATE WAY level

How will you create the custom validators in Spring?


Spring security internal workflow
how spring security from authentication works 
UsernamePasswordAuthenticationFilter 
	attemptAuthentication
	

NoopPasswordEncoder is singleton class available in spring framework



â€“---++++
courses:
https://courses.in28minutes.com/p/spring-boot-for-beginners-in-10-steps
https://sso.teachable.com/secure/164090/users/sign_up?after_success_url=%2Fsecure%2F164090%2Fcheckout%2F1561785%2F5-day-learning-challenge-get-started-with-spring-and-spring-boot


