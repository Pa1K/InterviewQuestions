Spring wt version is used
spring 4 features
spring 5 features
cutting point 
how do u handle custom exceptions in spring
@InitBinder
Flatmap
unit testing using spring
wt dependecnies are needed to see test reports

diff types of IoC Containers
bean factory vs application context
adv of application context over bean factory
@Required
QueryParams
RequestParams
actuator
diff rest endpoints provided by actuator
Hystrix diff annotation
profiles
global exception handling
Testing annotations

Spring Boot:
How do handle security in Spring boot application
How do u run Springboot in other port
How do u run SB applications in another server by removing tomcat
Annotations specifically used in Springboot
What is the significance of @componentscan @configuration
What @enableautoconfiguration does
Example of stater packages
How do u connect to backend

1. diff b.w controller and rest controller 
@RestController = @Controller + @ResponseBody

@RequestMapping(value="/<uri>", method=RequestMethod.POST, produces="application/json")
produces="application/json" or "application/xml" - method produces output in that format
@RequestBody
---------
2. diff b.w spring and spring boot
spring - 
provides multiple modules like (spring core, spring aop, spring jdbc)

Dependency Injection using @Component, @Autowired
@Component - we tell Spring framework, this is a bean that you need to manage
@Autowired - find correct match for this specific type and autowire it in.

Spring solved the following problems
1. Duplication/Plumbing Code -
Spring JDBC, Spring MVC, Spring AOP, Spring ORM, Spring JMS, Spring Test

2. Good Integration with Other frameworks
Hibernate for ORM
iBatis for Object Mapping
JUnit & Mockito for Unit Testing

Why we need Spring Boot -
Spring based applications have a lot of configuration

Autoconfiguration
Starter projects

spring boot -
helps to create standalone application
less or almost zero configuration
Autoconfiguration is a special feature in spring boot

Benefits of Spring Boot over Spring -
Dependency resolution
Min configuration
Embedded server for testing
Bean auto scan
Health metrics

Bean auto scan
spring - 
<context:component-scan base-package="com.*"></context:component-scan>

spring-boot -
@SpringBootApplication
@ComponentScan(base-package="")
or
if don't want to use the ComponentScan follow package structure
basepackage is where main method present
for remaining follow basepackage.controller/service like that so no need to mention ComponentScan
---------------------
3. diff b.w component and service annotation

@Component  - marks java class as bean
@Service -  service layer classes for intent - service layer
@Repository -  for DAO layer  
@Controller  - Presentation layer
@Configuration - a class contains one more beans defined inside class

@Bean - to declare a single bean explicitly 
------------
4. profiles in spring

No active profile set, falling back to default properties: default
application.yml
spring.profiles.active: test -- then test profile is used
application-<profileName>.<extn> -- application-test.yml
or
java -jar spring-boot-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=test

selecting beans by profile -
@Profile("<env>") on top of bean
----------------
ConfigurableApplicationContext context = SpringApplication.run(class, args); 
This is initialisation of spring container

When we annotate a class with @Component, a bean/object of that class created.
context.getBean(ClassName) - here we are getting object of ClassName from the container.

By default, spring follows singleton design pattern i.e creates an singleton object/bean for all @Component and similar annotated classes.

If we want to create multiple references/objects/beans of a class then we need to use the following annonation
@Scope(value="prototype")
But now spring doesn't create any instance of the class unless we call getBean().

When a classA is dependent on  classB,
Then we need to annotate classB with @Component, so bean is created for classB.
Now we need to inject/use classB bean/object in classA,
So by adding @Autowired classB instaceName in classA, we can use classB in classA.

By default, spring creates bean based on ClassName, if we want to create a bean using any specific name then we need to mention like below.
@Component("withwhatNameBeanNeedtobeCreated)

@Autowired -- searchs by type i.e ClassName
@Qualifier("nameOfthebeanwewantToSearch)
We need to add @Qualifier along with @Autowired if we want to search by name we given to bean.

Ref : https://youtu.be/K43qyHJXmWI
------
ApplicationContext context = new AnnonationConfigApplicationContext(AppConfig.class); 
This is spring container

ClassA classA = context.getBean(ClassA.class);

@Configuration
Class annotated with @Configuration i.e AppConfig is responsible for bean creation.

@Configuration
public class AppConfig {

@Bean
public ClassA getInstance(){
return new ClassA();
}

}

Ref: https://youtu.be/5zUTc-kge8I
-------
diff types of Spring IOC Containers -
https://www.baeldung.com/spring-beanfactory-vs-applicationcontext
ApplicationContext  - is interface
BeanFactory

AnnotationConfigApplicationContext
ClasspathXMLApplicationContext
FileSystemXMLApplicationContext

The Spring Framework comes with two IOC containers – 
BeanFactory ( Lazy Loading) and ApplicationContext(Eager Loading). 
The BeanFactory is the most basic version of IOC containers, and the ApplicationContext extends the features of BeanFactory.

BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. Thus, BeanFactory is lightweight as compared to ApplicationContext.
The beans defined in our BeanFactory will be loaded only when we explicitly call the getBean() method.

ApplicationContext is considered a heavy IOC container because its eager-loading strategy loads all the beans at startup. 
BeanFactory is lightweight by comparison and could be handy in memory-constrained systems.

 why ApplicationContext is preferred for most use cases.
 provides messaging (i18n or internationalization) functionality, 
 event publication functionality, 
 annotation-based dependency injection, and easy integration with Spring AOP features along with beanfactory features
 
 Apart from this, the ApplicationContext supports almost all types of bean scopes, but the BeanFactory only supports two scopes — Singleton and Prototype. 
 Therefore, it's always preferable to use ApplicationContext when building complex enterprise applications.
 
 Automatic Registration of BeanFactoryPostProcessor and BeanPostProcessor
 The ApplicationContext automatically registers BeanFactoryPostProcessor and BeanPostProcessor at startup. On the other hand, the BeanFactory does not register these interfaces automatically.


Resource res = new ClassPathResource("ioc-container-difference-example.xml");
BeanFactory factory = new XmlBeanFactory(res);

ApplicationContext context 
      = new ClassPathXmlApplicationContext("ioc-container-difference-example.xml");
    
Therefore, it's always advisable to use ApplicationContext because Spring 2.0 (and above) heavily uses BeanPostProcessor.

we should use BeanFactory only when memory consumption is critical.
 if you're using the plain BeanFactory, then features like transactions and AOP will not take effect 
 -----------
What're diff contexts available in spring and when to  use them?
ApplicationContext context = new AnnonationConfigApplicationContext(AppConfig.class);

ConfigurableApplicationContext context = SpringApplication.run(class, args); 
This is initialisation of spring container

What are diff ways of getting a bean from container other than context.getBean()

How to inject a bean by not using @Autowired?
What're diff ways to inject a bean by not using @Autowired?

What're uses of @Qualifer?

------
How does basic authentication works in REST API?
session based
JWT based

session based or JWT based , JWT based is prefered
as we may have multiple servers and session is specific to a server

we wll get JWT token once authentication done
so JWT is for authorisation

what is content negotiation?
consumes={MediaType.APPLICATION_XML_VALUE,MediaType.APPLICATION_JSON_VALUE},
produces={MediaType.APPLICATION_JSON_VALUE}

What are cross cutting concerns?
For all cross cutting concerns Spring AOP is solution

How do we implement cross cutting concerns in microservices architecture?
GATE WAY level

How will you create the custom validators in Spring?


Spring security internal workflow
how spring security from authentication works 
UsernamePasswordAuthenticationFilter 
	attemptAuthentication
	

NoopPasswordEncoder is singleton class available in spring framework
--------------
how do you secure your rest api
How to secure rest api using spring boot
1. Setup
2. Web page
3. Rest service
4. Default security
5. Custom security

Actuator for monitoring application
Devtools for making developement faster

For Jsp support add the following dependency
org.apache.tomcat.embed
tomcat-embed-jasper
provided

Add spring boot starter security as dependency

Auto configuration
Mapping filter : springSecurityFilterChain to /*
Default security password:
Basic authentication is default
Default user name is user

2 roles
User, admin

@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter{

//Authentication - user -- roles
@Override
protected void configure(AuthenticationManagerBuilder  auth) throws Exception{
auth.inMemoryAuthentication().withUser("user1").password("secret 1").roles("USER").and().
								withUser("admin1").password ("secret 1").roles("USER","ADMIN");

}

//Authorisation - role -- access
protected void configure(HttpSecurity http) throws Exception {
http.httpBasic().and().authorizeRequests.antMatchers("/students/**").hasRole("USER").
										 antMatchers("/**").hasRole("ADMIN").and().csrf().disable().headers().frameOptions().disable();
}

}




how to JWT Authorisation in Spring security from scratch
https://www.youtube.com/watch?v=X80nJ5T7YpE

Objectives -
create a new authentication endpoint
examine every incoming request for valid JWT and authorize

Step 0 -
A starter Spring Security Application with One hard-coded user

dependencies : web, security


import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
@EnableWebSecurity
public class SecurityConfigurer extends WebSecurityConfigurerAdapter{

	@Autowired
	private MyUserDetailsService myUserDetailsService;
	
	@Override
	protected void configure(AuthenticationManagerBuilder  auth) throws Exception{
		auth.userDetailsService(myUserDetailsService);
	}
	
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}

}

NoOpPasswordEncoder - don't do any hashing to incoming password

import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.core.userdetails.User;
@Service
public class MyUserDetailsService implements UserDetailsService {

	@Override
	public UserDetails loadUserByUsername(String userName) throws UsernameNotFoundException {
		return new User("foo","foo",new ArrayList<>());
	}

}


add the following dependencies to use JWT tokens
io.jsonwebtoken, jjwt, 0.9.1 - this lets us to create JWTs and validate JWTs
javax.xml.bind, jaxb-api, 2.3.0 - this need to be added if we are using java 9 or more, removed from JDK for modularity purpose


public class JwtUtil {
	
	private String SECRET_KEY = "secret";
	
	public String generateToken(UserDetails userDetails){
		Map<String, Object> claims = new HashMap<>();
		return createToken(claims, userDetails.getUserName());
	}
	
	public createToken(Map<String, Object> claims, String subject){
		return Jwts.builder().setClaims(claims).setSubject(subject).setIssuedAt(new Date(System.currentTimeMillis()))
				.setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10))
				.signWith(SignatureAlgorithm.HS256, SECRET_KEY).compact();
	}
	
	
	public Boolean validateToken(String token, UserDetails userDetails) {
		final String username = extractUsername(token);
		return (username.equals(userDetails.getUserName()) && !isTokenExpired(token));
	}
	
	public String extractUsername(String token){
		return extractClaim(token,Claims::getSubject);
	}
	
	private Boolean isTokenExpired(String token) {
		return extractExpiration(token).before(new Date());
	}
	
	public Date extractExpiration(String token) {
		return extractClaim(token,Claims::getExpiration);
	}
	
	public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
		final Claims claims = extractAllClaims(token);
		return claimsResolver.apply(claims);
	}
	
	private Claims extractAllClaims(String token){
		return Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token).getBody();
	}
	
}


Step 1 -
A /authenticate API endpoint 
- Accepts user ID and password
- Returns JWT as response

public class AuthenticationRequest {
	private String username;
	private String password;
	
	// getter and setters
	
	// constructor taking username, password as args
	
	// default constructor
}

public class authenticationResponse {
	private final Sting jwt;
	
	// getter for jwt
	
	// constructor taking jwt as arg
}



@RestController
public class HelloResource {

	@Autowired
	private AuthenticationManager authenticationManager;
	
	@Autowired
	private MyUserDetailsService userDetailsService;
	
	@Autowired
	private JwtUtil jwtUtil;
	
	@RequestMapping("/hello")
	public String hello(){ return "Hello World"; }
	
	@RequestMapping("/authenticate",method=RequestMethod.POST)
	public ResponseEntity<?> createAuthenticateToken(@RequestBody AuthenticateRequest authenticateRequest) throws Exception {
		try {
		authenticationManager.authenticate(
				new UsernamePasswordAuthenticationToken(authenticateRequest.getUserName(), authenticateRequest.getPassword())
				);
		}
		catch (BadCredentialsException e) {
			throw new Exception("Incorrect username or password",e);
		}
		
		final UserDetails userDetails = userDetailsService.loadUserByUsername(authenticateRequest.getUserName());
		
		final String jwt = jwtUtil.generateToken(userDetails);
		
		return ResponseEntity.ok(new AuthenticateResponse(jwt));
	}
}


we need to inform spring security to bypass authentication if some calls authenticate endpoint

add the following in SecurityConfigurer class,

@Override
protected void configure(HttpSecurity http) throws Exception {
	http.csrf().disable()
		.authorizeRequests().antMatchers("/authenticate").permitAll()
		.anyRequest().authenticated();
}

Run the application, we will get the following
Action:
Consider defining a bean of type 'org.springframework.security.authentication.AuthenticationManager' in your configuration.

	@Autowired
	private AuthenticationManager authenticationManager;
this used to work in old versions of spring boot,
spring boot 2.0 we need to define a bean for AuthenticationManager

add the following in SecurityConfigurer class,
@Override
@Bean
public AuthenticationManager authenticateManagerBean() throws Exception {
	return super.authenticateManagerBean();
}

from POSTMAN:
POST http://localhost:8080/authenticate
HEADERS Content-Type : application/json
Body {"username":"foo", "password":"foo"}
response jwt token generated

GET http://localhost:8080/hello
HEADERS 
Content-Type : application/json
Authorization : Bearer jwtToken

Getting 403

Step 2 -
Intercept all incoming requests
- Extract JWT from the header
- Validate and set in execution context

Intercept all incoming requests
for this we need filters, there are diff filters available

import org.springframework.web.filter.OncePerRequestFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.FilterChain;
import javax.Server.ServletException;
import java.io.IOException;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {

	@Autowired
	private MyUserDetailsService userDetailsService;
	
	@Autowired
	private JwtUtil jwtUtil;
	
	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {
		
		final String authorizationHeader = request.getHeader("Authorization");
		
		String username = null;
		String password = null;
		
		if (authorizationHeader!=null && authorizationHeader.startsWith("Bearer ")) {
			jwt = authorizationHeader.subString(7);
			username = jwtUtil.extractUsername(jwt);
		}
		
		if(username!=null && SecurityContextHolder.getContext().getAuthentication() == null){
			UserDetails userDetails = this.userDetailsService.loadUserByUsername(username);
			
			if(jwtUtil.validateToken(jwt,userdetails)){
				UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(
							userDetails, null, userDetails.getAuthorities());
				usernamePasswordAuthenticationToken.setDetails(
							new WebAuthenticationDetailsSource().buildDetails(request));
				SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);		
				
			} 
		}
		
		chain.doFilter(request,response);
	}
}


now we created filter chain, we need to use it.


@Override
protected void configure(HttpSecurity http) throws Exception {
	http.csrf().disable()
		.authorizeRequests().antMatchers("/authenticate").permitAll()
		.anyRequest().authenticated()
		.and().sessionManagement()
		.sessionCreationPolicy(SessionCreationPolicy.STATELESS);
		
	http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class); // means call jwtRequestFilter before calling UsernamePasswordAuthenticationFilter
}

	.and().sessionManagement()
		.sessionCreationPolicy(SessionCreationPolicy.STATELESS); 
	means don't do session mangement 
	
	
Questions -
WebSecurityConfigurerAdapter
AuthenticationManagerBuilder
inMemoryAuthentication()
HttpSecurity
	
@EnableWebSecurity vs @Configuration
UserDetailsService
loadUserByUsername
UserDetails
User
setClaims, wt's claims
Function<Claims, T> claimsResolver
ResponseEntity<?>
AuthenticationManager
authenticate
UsernamePasswordAuthenticationToken
ResponseEntity.ok(new AuthenticateResponse(jwt))
OncePerRequestFilter
doFilterInternal
SecurityContextHolder.getContext().getAuthentication()
userDetails.getAuthorities()
WebAuthenticationDetailsSource
chain.doFilter(request,response);
UsernamePasswordAuthenticationFilter

-----------
Spring Boot Global Excetion Handling -
https://www.youtube.com/watch?v=hLlGAQ5NfTE

Q) Need of  Global Exception handling. Why to do Spring Boot Exception Handling? Global exception handling in spring boot needs?
In Real World projects, Its very important to handle errors correctly and simultaneously provide meaningful error messages to the clients too. 
Hence we need Exception handling in Spring boot , Spring Boot Exception Handling or Global exception handling in spring boot.
Today we will see how to properly handle errors specifically in spring boot.
Prerequisite : Spring boot, Creation of Rest APIs

Q) How can we make Error response clear in spring boot exception handling
We are lucky enough that Spring already comes with the built in support for error handling. 
It’s our job to understand and implement it. And today we are going to do that to do exception handling in Spring Boot Application

Q) Annotation used for Spring Boot Error Handling 
For Exception handling in spring boot in global exception handling , we need following annotations - 

@RestController : 
is the base annotation for classes that handle REST operations.

@ControllerAdvice : 
The @ControllerAdvice annotation handles exceptions globally – it allows you to use the same ExceptionHandler for multiple controllers. 
This way, we can define how to treat an exception in just one place because this handler will be called whenever the exception is thrown from classes that are covered by ControllerAdvice.
as the name suggests, is “Advice” for multiple controllers.
allows our class to be a global interceptor of exceptions thrown by methods annotated by @RequestMapping.

@ExceptionHandler  : 
Spring annotation that provides a mechanism to treat 
exceptions that are thrown during execution of handlers (Controller operations). 
This annotation, if used on methods of controller classes, will serve as the entry point for handling exceptions thrown within this controller only. 

Altogether, the most common way is to use @ExceptionHandler on methods of @ControllerAdvice classes so that the exception handling will be applied globally or to a subset of controllers.


@ExceptionHandler and @ControllerAdvice are used to define a central point for treating exceptions and wrapping them up in a class.

@ResponseStatus
You can also override the existing exception handlers. 
Spring Boot’s built-in exception class ResponseEntityExceptionHandler has multiple methods that you can override to customize the exception handling further.


@ControllerAdvice
public class MyControllerAdvice {
	
	@ExceptionHandler(CustomExceptionClassName.class)
	public ResponseEntity<String> handleException(CustomException customException)	{
		return new ResponseEntity<String>("ErrorMsgWhichWeWanttoShowtoUser","StatusCode");
	}
	
	@ExceptionHandler(BuiltinExceptionClassName.class)
	public ResponseEntity<String> handleNoSuchElemenyException(BuiltinException builtinException)	{
		return new ResponseEntity<String>("ErrorMsgWhichWeWanttoShowtoUser","StatusCode");
	}
}


@ControllerAdvice
public class MyControllerAdvice extends ResponseEntityExceptionHandler {
	
	@ExceptionHandler(CustomExceptionClassName.class)
	public ResponseEntity<String> handleException(CustomException customException)	{
		return new ResponseEntity<String>("ErrorMsgWhichWeWanttoShowtoUser","StatusCode");
	}
	
	@ExceptionHandler(BuiltinExceptionClassName.class)
	public ResponseEntity<String> handleNoSuchElemenyException(BuiltinException builtinException)	{
		return new ResponseEntity<String>("ErrorMsgWhichWeWanttoShowtoUser","StatusCode");
	}
	
	
	//we can override the methods in ResponseEntityExceptionHandler
	@Override
	protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(HttpRequestMethodNotSupportedException ex,
				HttpHeader headers, HttpStatus status, WebRequest request) {
				
				return new ResponseEntity<Object>("please change http method type", HttpSatus.NOT_FOUND);
				}
}
-------------
#db rollback in spring 

@Transactional for unchecked/runtime exception on top of method definition
@Transactional(rollbackFor=CheckedException.class) for checked exception


dependecies : Lombok, Spring Web, Spring Data JPA, MySQL Driver
import lombok.Data;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "PASSENGER_INFO")
public class PassengerInfo {

	@Id
	@GeneratedValue
	private Long pId;
	
	@JsonFormat(shape=JsonFormat.Shape.STRING, pattern="dd-MM-yyyy")
	private Date travelDate;
	
}


public class PaymentInfo {
	
	@Id
	@GeneratedValue(generator="uuid2")
	@GenericGenerator(name="uuid2", strategy="org.hibernate.id.UUIDGenerator")
	private String paymentId;
}


JpaRepository<ClassName,PrimaryKey>
public interface PassengerInfoRepository extends JpaRepository<PassengerInfo,Long> {

}

application.properties:
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/pavan
spring.datasource.username=root
spring.datasource.password=password

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update -- for auto creation of tables
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

server.port=9090

Service:
@Transactional
public FlightBookingAck bookFlightTicket(FlightBookingRequest request){
	
	PassengerInfo passengerInfo = request.getPassengerInfo();
	passengerInfoRepository.save(passengerInfo); // persisting to DB
	
	PaymentInfo paymentInfo = request.getPaymentInfo();
	
	PaymentUtils.validateCreditLimit(paymentInfo.getAccountNo(),passengerInfo.getFare()); //Runtime or unchecked exception
	
	paymentInfo.setPassengerId(passengerInfo.getPid());
	paymentInfo.setAmount(passengerInfo.getFare());
	
	paymentInfoRepository.save(paymentInfo);
	
	
	return new FlightBookingAck("SUCCESS", passengerInfo.getFare(), UUID.randomUUID().toString().split("-")[0],passengerInfo);
	
}


Add @Transactional to the method which does insert/update to multiple tables
and add @EnableTransactionManagement to application class
so if any of the db query failed all are rolled back

Ref:
https://www.youtube.com/watch?v=95kxPSbHzVg

Incase of checked exceptions, 
previously executed transactions don't get rolled back automatically,
even if we have used transaction annotation. 
We need to inform the application how to handle roll back in event of checked exception, 
This is achieved using the rollbackFor annotation.

@Transactional(rollbackFor=CheckedException.class)
methodWhichThrowCheckedException() throws CheckedException{}

Ref: 
https://www.youtube.com/watch?v=WurOjaDRGMQ&list=WL&index=1
https://www.javainuse.com/spring/boot-rollback
-------
@Transactional(readOnly=false, isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED)
check abt isolation and propagation


what is transaction management
diff transaction propagation types
transaction isolation levels
---------



courses:
https://courses.in28minutes.com/p/spring-boot-for-beginners-in-10-steps
https://sso.teachable.com/secure/164090/users/sign_up?after_success_url=%2Fsecure%2F164090%2Fcheckout%2F1561785%2F5-day-learning-challenge-get-started-with-spring-and-spring-boot


